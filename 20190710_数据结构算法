# 入门
数据结构：数组、链表、栈、队列、堆、二叉树、图、散列表、跳表、trie树
算法：分治、排序、递归、动归、贪心、哈希、二分查找、搜索、回溯、字符串匹配
复杂度：大O、平均、均摊
均摊 极少情况高级别，且低高级别出现具有时序性

# 数组
1、为什么从0开始
    因为数组内存连续，可以使用offset确定地址，从1开始汇编多一个减一步骤
2、特点：连续内存、相同的类型
3、数组和链表的区别
              索引    搜索    增删
        数组   O1   On到Ologn  On
        链表   On      On      O1
    数组支持随机访问，链表增删快
4、数组删除怎么加速
    应用标记删除算法（JVM标记删除的不足：①少量垃圾时效率高②产生内存碎片）
5、容器的优势
    支持动态扩容
6、数组访问越界造成死循环
    与编译器有关，内存分配时，栈内从高位向低位分配

# 链表
1、LRU缓存淘汰算法（最近最少使用原则）=链表+散列表
2、双向链表的优势
    删除操作有两种删除给定的节点、删除指定节点等于多少，第一种情况明显快。
    空间换时间的典型
3、频繁的增删，可能造成内存碎片，JAVA里面可能会频繁GC
4、指针的认识
    将某个变量赋值给某个指针 == 将变量的地址赋值给指针
    指针存了某个变量的地址   ==   通过这个指针可以访问这个变量
    例：
        删除链表当前节点p的下一个节点
            p->next = p->next->next
        增加节点x，当前p
            x.next = p.next
            p.next = x
5、链表编程注意
    NULL、一个、两个、head、tail节点
    
# 栈
1、应用
    chrome浏览器前进后退、括号匹配、函数栈
2、顺序栈和链式栈
3、与内存堆栈区别
    堆栈是真实物理区，保存局部变量
4、为什么用栈保存临时变量
    函数调用进入被调函数，对于数据而已是作用的变化，栈符合进入被调函数分配临时变量，函数结束释放，又回到之前作用域。

# 队列
1、应用
    线程池、阻塞队列、并发队列

# 递归
1、优化：递归时用散列表保存已存储的值
2、怎么调试
    打印日志发现，递归值  结合条件断点进行调试
3、尾递归
    递归在最后，保存了上一次的结果，主要节约空间，减少少量时间

# 排序
    冒泡（稳定）、插入（稳定）、选择       On2     基于比较   原位排序
    快排（不）、归并（稳定）             Onlogn   基于比较   归并不是原位排序
    桶、计数、基数
1、为什么插入比冒泡好：只有一个步骤插入，冒泡三个步骤
2、归并和快排见
